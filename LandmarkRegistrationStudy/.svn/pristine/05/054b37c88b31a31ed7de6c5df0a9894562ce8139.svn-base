import os
import unittest
import vtk, qt, ctk, slicer
from slicer.ScriptedLoadableModule import *
import logging
import numpy as np

#
# PreProcessLandmarks
#

class PreProcessLandmarks(ScriptedLoadableModule):
  """Uses ScriptedLoadableModule base class, available at:
  https://github.com/Slicer/Slicer/blob/master/Base/Python/slicer/ScriptedLoadableModule.py
  """

  def __init__(self, parent):
    ScriptedLoadableModule.__init__(self, parent)
    self.parent.title = "PreProcessLandmarks" # TODO make this more human readable by adding spaces
    self.parent.categories = ["Scoliosis"]
    self.parent.dependencies = []
    self.parent.contributors = ["Ben Church - Queen's University, PerkLab"]
    self.parent.helpText = """
    This module can be used to extrapolate or interpolate incomplete scans of the
    transverse processes"""
    self.parent.acknowledgementText = """ """ # replace with organization, grant and thanks.

#
# PreProcessLandmarksWidget
#

class PreProcessLandmarksWidget(ScriptedLoadableModuleWidget):
  """Uses ScriptedLoadableModuleWidget base class, available at:
  https://github.com/Slicer/Slicer/blob/master/Base/Python/slicer/ScriptedLoadableModule.py
  """

  def setup(self):
    self.logic = None           # Use class variable to store logic to keep performing operations on same nodes
    
    ScriptedLoadableModuleWidget.setup(self)

    # Instantiate and connect widgets ...

    # User interface for incomplete landmark set repair
    RepairInterface = ctk.ctkCollapsibleButton()
    RepairInterface.text = "Markups node repair"
    self.layout.addWidget(RepairInterface)
    RepairInterfaceLayout = qt.QGridLayout(RepairInterface)
    RepairInterfaceLayout.setHorizontalSpacing(12)
    
    # Dropdown list to select MarkupsNode for repair
    self.AnatomySelector = slicer.qMRMLNodeComboBox()
    self.AnatomySelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode",]
    self.AnatomySelector.selectNodeUponCreation = True
    self.AnatomySelector.enabled  = True
    self.AnatomySelector.addEnabled = True
    self.AnatomySelector.noneEnabled = True
    self.AnatomySelector.removeEnabled = True
    self.AnatomySelector.renameEnabled = True
    self.AnatomySelector.toolTip = "Choose the incomplete patient landmark set to be repaired"
    RepairInterfaceLayout.addWidget(qt.QLabel("Node to repair -->"), 1, 0, 1, 1)
    RepairInterfaceLayout.addWidget(self.AnatomySelector, 1, 1, 1, 3)
    self.AnatomySelector.setMRMLScene(slicer.mrmlScene)
    
    self.CategorizeLeftRightButton = qt.QPushButton("Categorize left-right landmarks")
    self.CategorizeLeftRightButton.toolTip = "Groups selected nodes landmarks into left and right landmark nodes used for repair operations"
    RepairInterfaceLayout.addWidget(self.CategorizeLeftRightButton, 2, 1, 1, 3)
    
    self.LeftSideSelector = slicer.qMRMLNodeComboBox()
    self.LeftSideSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode",]
    self.LeftSideSelector.selectNodeUponCreation = False
    self.LeftSideSelector.enabled  = True
    self.LeftSideSelector.addEnabled = False
    self.LeftSideSelector.noneEnabled = True
    self.LeftSideSelector.removeEnabled = True
    self.LeftSideSelector.renameEnabled = False
    self.LeftSideSelector.toolTip = "Stores the left side of the patient's landmarks being repaired"
    self.LeftSideSelector.setMRMLScene(slicer.mrmlScene)

    self.RightSideSelector = slicer.qMRMLNodeComboBox()
    self.RightSideSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode",]
    self.RightSideSelector.selectNodeUponCreation = False
    self.RightSideSelector.enabled  = True
    self.RightSideSelector.addEnabled = False
    self.RightSideSelector.noneEnabled = True
    self.RightSideSelector.removeEnabled = True
    self.RightSideSelector.renameEnabled = False
    self.RightSideSelector.toolTip = "Stores the right side of the patient's landmarks being repaired"
    self.RightSideSelector.setMRMLScene(slicer.mrmlScene)
    
    RepairInterfaceLayout.addWidget(qt.QLabel(" "), 3, 1, 1, 3)
    
    RepairInterfaceLayout.addWidget(qt.QLabel("Unrepaired"), 4, 1, 1, 1)
    RepairInterfaceLayout.addWidget(qt.QLabel("Tentative patch"), 4, 3, 1, 1)
    
    self.LeftPatchSelector = slicer.qMRMLNodeComboBox()
    self.LeftPatchSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode",]
    self.LeftPatchSelector.selectNodeUponCreation = False
    self.LeftPatchSelector.enabled  = True
    self.LeftPatchSelector.addEnabled = False
    self.LeftPatchSelector.noneEnabled = True
    self.LeftPatchSelector.removeEnabled = True
    self.LeftPatchSelector.renameEnabled = False
    self.LeftPatchSelector.toolTip = "Stores the landmarks node with which the module will patch Unrepaired Left" 
    self.LeftPatchSelector.setMRMLScene(slicer.mrmlScene)

    RepairInterfaceLayout.addWidget(qt.QLabel("Left"), 5, 0, 1, 1)
    RepairInterfaceLayout.addWidget(self.LeftSideSelector, 5, 1, 1, 1)
    RepairInterfaceLayout.addWidget(self.LeftPatchSelector, 5, 3, 1, 1)

    self.RightPatchSelector = slicer.qMRMLNodeComboBox()
    self.RightPatchSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode",]
    self.RightPatchSelector.selectNodeUponCreation = False
    self.RightPatchSelector.enabled  = True
    self.RightPatchSelector.addEnabled = False
    self.RightPatchSelector.noneEnabled = True
    self.RightPatchSelector.removeEnabled = True
    self.RightPatchSelector.renameEnabled = False
    self.RightPatchSelector.toolTip = "Stores the landmarks node with which the module will patch Unrepaired Right" 
    self.RightPatchSelector.setMRMLScene(slicer.mrmlScene)
    
    RepairInterfaceLayout.addWidget(qt.QLabel("Right"), 6, 0, 1, 1)
    RepairInterfaceLayout.addWidget(self.RightSideSelector, 6, 1, 1, 1)
    RepairInterfaceLayout.addWidget(self.RightPatchSelector, 6, 3, 1, 1)
  
    RepairInterfaceLayout.addWidget(qt.QLabel(" "), 7, 1, 1, 3)
   
    self.RepairSideSelector = slicer.qMRMLNodeComboBox()
    self.RepairSideSelector.nodeTypes = ["vtkMRMLMarkupsFiducialNode",]
    self.RepairSideSelector.selectNodeUponCreation = False
    self.RepairSideSelector.enabled  = True
    self.RepairSideSelector.addEnabled = False
    self.RepairSideSelector.noneEnabled = True
    self.RepairSideSelector.removeEnabled = True
    self.RepairSideSelector.renameEnabled = False
    self.RepairSideSelector.toolTip = "Use to select the node containing the spine side to have a patch of points generated"
    self.RepairSideSelector.setMRMLScene(slicer.mrmlScene)
    RepairInterfaceLayout.addWidget(qt.QLabel("Make patch for:"), 8, 0, 1, 1)
    RepairInterfaceLayout.addWidget(self.RepairSideSelector, 8, 1, 1, 3)
    
    self.AutoCompleteButton = qt.QPushButton("Auto-Complete")
    self.AutoCompleteButton.toolTip = "Guess missing landmarks"
    self.AutoCompleteButton.enabled = True
    RepairInterfaceLayout.addWidget(self.AutoCompleteButton, 9, 0, 1, 1)
   
    self.MergeTentativePatchButton = qt.QPushButton("Merge Patch")
    self.MergeTentativePatchButton.toolTip = "Replace selected side node with itself merged with its patch"
    self.MergeTentativePatchButton.enabled = True
    RepairInterfaceLayout.addWidget(self.MergeTentativePatchButton, 9, 1, 1, 1)
   
    self.RepairNodeButton = qt.QPushButton("Repair landmarks node")
    #self.RepairNodeButton.toolTip = "Currently seperates right from left sided points"
    RepairInterfaceLayout.addWidget(self.RepairNodeButton, 10, 0, 1, 4)
    
    
    # Dropdown list to store output repaired MarkupsNode
    self.RepairedNodeStorage = slicer.qMRMLNodeComboBox()
    self.RepairedNodeStorage.nodeTypes = ["vtkMRMLMarkupsFiducialNode",]
    self.RepairedNodeStorage.selectNodeUponCreation = False
    self.RepairedNodeStorage.enabled  = True
    self.RepairedNodeStorage.addEnabled = False
    self.RepairedNodeStorage.noneEnabled = True
    self.RepairedNodeStorage.removeEnabled = True
    self.RepairedNodeStorage.renameEnabled = False
    self.RepairedNodeStorage.toolTip = "Stores combined repaired left and right sides - repaired version of input repair node"
    RepairInterfaceLayout.addWidget(self.RepairedNodeStorage, 12, 0, 1, 3)
    RepairInterfaceLayout.addWidget(qt.QLabel(" <-- Repaired node"), 12, 3, 1, 1)
    self.RepairedNodeStorage.setMRMLScene(slicer.mrmlScene)
    
    # Button connections
    self.CategorizeLeftRightButton.connect('clicked(bool)', self.OnCategorizeLeftRight)
    #self.AutocompleteLeftButton.connect('clicked(bool)', self.AutocompleteLeft)
    #self.AutocompleteRightButton.connect('clicked(bool)', self.AutocompleteRight)
    self.AutoCompleteButton.connect('clicked(bool)', self.AutoComplete)
    self.MergeTentativePatchButton.connect('clicked(bool)', self.MergeTentativePatch)
    self.RepairNodeButton.connect('clicked(bool)', self.OnRepairButtonClicked)
    
    # Interface connections
    #self.RepairSideSelector.connect('clicked(bool)', self.OnRepairBoxClicked)
    self.RepairSideSelector.connect('currentNodeChanged(bool)', self.OnRepairSideSelected)
    
    # Reload module button
    self.reloadButton = qt.QPushButton('Reload module')
    RepairInterfaceLayout.addWidget(self.reloadButton, 13, 0, 1, 4)

    # connections
    self.reloadButton.connect('clicked(bool)', self.OnReloadButton)
    
    # Add vertical spacer
    self.layout.addStretch(1)

  def cleanup(self):
    pass

  def OnCategorizeLeftRight(self):
    if self.AnatomySelector.currentNode() == None:
      print "Error - require MarkupsNode to segment into left and right sides"
      return
    
    if self.logic == None:
      self.logic = PreProcessLandmarksLogic(self.AnatomySelector.currentNode())
    
    (LeftSide, RightSide) = self.logic.CategorizeLeftRight(4)
    slicer.mrmlScene.AddNode(LeftSide)
    slicer.mrmlScene.AddNode(RightSide)
    LeftSide.GetDisplayNode().SetSelectedColor(0,0,1)
    RightSide.GetDisplayNode().SetSelectedColor(0,0,1)
    self.LeftSideSelector.setCurrentNode(LeftSide)
    self.RightSideSelector.setCurrentNode(RightSide)
    
  def AutoComplete(self):
    #RepairedNode = slicer.vtkMRMLMarkupsFiducialNode()
    if self.logic == None:
      self.logic = PreProcessLandmarksLogic(self.AnatomySelector.currentNode())
      (LS, RS) = self.logic.CategorizeLeftRight(4)
      
    if self.NodeToPatch.GetName().__contains__("Left"):
      PatchNode = (self.logic.LeftSide.PredictAndImputeOmissions())
      slicer.mrmlScene.AddNode(PatchNode)
      self.LeftPatchSelector.setCurrentNode(PatchNode)
      self.LeftPatchSelector.currentNode().GetDisplayNode().SetSelectedColor(1,1,0)
    elif self.NodeToPatch.GetName().__contains__("Right"):
      PatchNode = (self.logic.RightSide.PredictAndImputeOmissions())
      slicer.mrmlScene.AddNode(PatchNode)
      self.RightPatchSelector.setCurrentNode(PatchNode)
      self.RightPatchSelector.currentNode().GetDisplayNode().SetSelectedColor(1,1,0)
    
  def MergeTentativePatch(self):
    if self.RepairSideSelector.currentNode() == self.LeftSideSelector.currentNode() and self.LeftPatchSelector.currentNode() != None:
      PatchedLeftNode = slicer.vtkMRMLMarkupsFiducialNode()
      PatchedLeftNode.Copy(self.logic.LeftSide.CombineNodeWithPatch(self.logic.LeftSide.MarkupsNode, self.logic.LeftSide.PatchNode))
      self.logic.LeftSide.MarkupsNode.Copy(PatchedLeftNode)
      PatchedLeftNode.SetName(self.LeftSideSelector.currentNode().GetName())
      slicer.mrmlScene.RemoveNode(self.LeftSideSelector.currentNode())
      slicer.mrmlScene.AddNode(PatchedLeftNode)
      self.RepairSideSelector.setCurrentNode(PatchedLeftNode)
      return
    if self.RepairSideSelector.currentNode() == self.RightSideSelector.currentNode() and self.RightPatchSelector.currentNode() != None:
      PatchedRightNode = slicer.vtkMRMLMarkupsFiducialNode()
      PatchedRightNode.Copy(self.logic.RightSide.CombineNodeWithPatch(self.logic.RightSide.MarkupsNode, self.logic.RightSide.PatchNode))
      self.logic.RightSide.MarkupsNode.Copy(PatchedRightNode)
      PatchedRightNode.SetName(self.RightSideSelector.currentNode().GetName())
      slicer.mrmlScene.RemoveNode(self.RightSideSelector.currentNode())
      slicer.mrmlScene.AddNode(PatchedRightNode)
      self.RightSideSelector.setCurrentNode(self.logic.RightSide.MarkupsNode)
      return
  
  def AddLandmark(self):
    return
    
  """
  def AutocompleteLeft(self):
    if self.logic == None:
      print "Logic lost"
      self.logic = PreProcessLandmarksLogic(self.AnatomySelector.currentNode())
      (LS, RS) = self.logic.CategorizeLeftRight(4)
    RepairedLeftNode = self.logic.LeftSide.PredictAndImputeOmissions()
    self.LeftPatchSelector.setCurrentNode(RepairedLeftNode)
    
  def AutocompleteRight(self):
    if self.logic == None:
      self.logic = PreProcessLandmarksLogic(self.AnatomySelector.currentNode())
      (LS, RS) = self.logic.CategorizeLeftRight()
    RepairedRightNode = self.logic.RightSide.PredictAndImputeOmissions()
    self.RightPatchSelector.setCurrentNode(RepairedRightNode)
  """
    
  def OnRepairButtonClicked(self):
    if self.logic == None:
      self.logic = PreProcessLandmarksLogic(self.AnatomySelector.currentNode())
    self.logic.RepairNode()
    
  def OnRepairSideSelected(self):
    MainRepairNode = self.AnatomySelector.currentNode()
    
    LeftSide = slicer.util.getNode(MainRepairNode.GetName()+"_Left")
    if LeftSide != None:
      LeftSide.GetDisplayNode().SetSelectedColor(0,0,1)
      
    RightSide = slicer.util.getNode(MainRepairNode.GetName()+"_Right")
    if RightSide != None:
      RightSide.GetDisplayNode().SetSelectedColor(0,0,1)
    
    self.NodeToPatch = self.RepairSideSelector.currentNode()
    if self.NodeToPatch != None:
      self.NodeToPatch.GetDisplayNode().SetSelectedColor(1,0,0)
    
    
  def OnReloadButton(self):
    self.logic = None
    #slicer.mrmlScene.Clear(0)
    print str(slicer.moduleNames.PreProcessLandmarks) + " reloaded"
    slicer.util.reloadScriptedModule(slicer.moduleNames.PreProcessLandmarks)
    
#
# PreProcessLandmarksLogic
#

class PreProcessLandmarksLogic(ScriptedLoadableModuleLogic):
  class PatientTransverseProcesses:
    def __init__(self, parent, Node):
      self.ParentLogic = parent
      # User definable parameters
      self.NumMarkupsForRunningClassification = 6
    
      self.MarkupsNode = slicer.vtkMRMLMarkupsFiducialNode()
      self.MarkupsNode.Copy(Node)
      self.MarkupsNode.SetAndObserveDisplayNodeID(Node.GetDisplayNodeID())
      self.LabelsCoords = [(self.MarkupsNode.GetNthFiducialLabel(i), self.MarkupsNode.GetMarkupPointVector(i,0)) for i in range(self.MarkupsNode.GetNumberOfFiducials())]
      
      PreExistingLeftNode = slicer.util.getNode(self.MarkupsNode.GetName() + "_Left")
      if PreExistingLeftNode != None:
        slicer.mrmlScene.RemoveNode(PreExistingLeftNode)
      PreExistingRightNode = slicer.util.getNode(self.MarkupsNode.GetName() + "_Right")
      if PreExistingRightNode != None:
        slicer.mrmlScene.RemoveNode(PreExistingRightNode)
      
      """      
      self.LeftSide = self.ParentLogic.SpineSide(self, (slicer.vtkMRMLMarkupsFiducialNode()))
      self.LeftSide.MarkupsNode.SetName(self.MarkupsNode.GetName() + "_Left")
      self.RightSide = self.ParentLogic.SpineSide(self, (slicer.vtkMRMLMarkupsFiducialNode()))
      self.RightSide.MarkupsNode.SetName(self.MarkupsNode.GetName() + "_Right")
      """
      
    def SortPointsVertically(self):
      self.MarkupsNode.RemoveAllMarkups()
      self.LabelsCoords = sorted(self.LabelsCoords, key=lambda Tup: -1*Tup[1][2])
      for i, Markup in enumerate(self.LabelsCoords):
        self.MarkupsNode.AddFiducialFromArray(Markup[1])
        self.MarkupsNode.SetNthFiducialLabel(i, Markup[0])
      
    def ClassifyLeftRight(self, WindowSize=-1):  
      if WindowSize < 2:
        WindowSize = self.NumMarkupsForRunningClassification
      self.SortPointsVertically()
      SortedPointsLeftVotes = len(self.LabelsCoords) * [0]
      SortedPointsRightVotes = len(self.LabelsCoords) * [0]
      for i in range(0, len(self.LabelsCoords)-WindowSize+1):
        MarkupsWindow = self.LabelsCoords[i:i+WindowSize]
        #print MarkupsWindow
        NormalizedWindow = self.AnisotrpoicNormalization(MarkupsWindow)
        (KmLabels, KmCentroids) = self.KMeans(NormalizedWindow, 2)

        # If KmLabel == 0 indicates a left-side point
        if KmCentroids[0][0] < KmCentroids[1][0]:
          for j, Label in enumerate(KmLabels):
            if Label == 0:
              SortedPointsLeftVotes[i + j] = SortedPointsLeftVotes[i + j] + 1
            else:
              SortedPointsRightVotes[i + j] = SortedPointsRightVotes[i + j] + 1
        else: # If KmLabel == 0 indicates a right-side point
          for j, Label in enumerate(KmLabels):
            #print i, j
            if Label == 0:
              SortedPointsRightVotes[i + j] = SortedPointsRightVotes[i + j] + 1
            else:
              SortedPointsLeftVotes[i + j] = SortedPointsLeftVotes[i + j] + 1
      
      NewLeftSide = slicer.vtkMRMLMarkupsFiducialNode()
      NewLeftSide.SetName(self.MarkupsNode.GetName() + "_Left")
      PreviousLeftSide = slicer.util.getNode(self.MarkupsNode.GetName() + "_Left")
      if PreviousLeftSide != None:
        slicer.mrmlScene.RemoveNode(PreviousLeftSide)
      
      NewRightSide = slicer.vtkMRMLMarkupsFiducialNode()
      NewRightSide.SetName(self.MarkupsNode.GetName() + "_Right")
      PreviousRightSide = slicer.util.getNode(self.MarkupsNode.GetName() + "_Right")
      if PreviousRightSide != None:
        slicer.mrmlScene.RemoveNode(PreviousRightSide)
      
      for i, UnclassifiedPoint in enumerate(self.LabelsCoords):
        #OriginalPointIndex = self.LabelsCoords.index(UnclassifiedPoint)
        #OriginalPoint = self.LabelsCoords[OriginalPointIndex]
        if SortedPointsLeftVotes[i] > SortedPointsRightVotes[i]:
          NewLeftSide.AddFiducialFromArray(UnclassifiedPoint[1])
          NewLeftSide.SetNthFiducialLabel(NewLeftSide.GetNumberOfFiducials()-1, UnclassifiedPoint[0] + '_Left')
        else:
          NewRightSide.AddFiducialFromArray(UnclassifiedPoint[1])
          NewRightSide.SetNthFiducialLabel(NewRightSide.GetNumberOfFiducials()-1, UnclassifiedPoint[0] + '_Right')

      self.LeftSide = self.ParentLogic.SpineSide(self, NewLeftSide)
      self.RightSide = self.ParentLogic.SpineSide(self, NewRightSide)
      
    def AnisotrpoicNormalization(self, PointSet):
      # Start by finding top and bottom points of spine for verticle normalization
      SetRight = -10000
      SetLeft = 10000
      SetFront = -10000
      SetBack = 10000
      SetTop = -10000
      SetBottom = 10000

      for Point in PointSet:
        Coords  = Point[1]
        if Coords[0] < SetLeft:
          SetLeft = Coords[0]
        if Coords[0] > SetRight:
          SetRight = Coords[0]
        if Coords[1] < SetBack:
          SetBack = Coords[1]
        if Coords[1] > SetFront:
          SetFront = Coords[1]
        if Coords[2] > SetTop:
          SetTop = Coords[2]
        if Coords[2] < SetBottom:
          SetBottom = Coords[2]
        
      SetHeight = SetTop - SetBottom
      SetWidth = SetRight - SetLeft
      SetDepth = SetFront - SetBack
      
      # (Re) initialize normalized point list
      NormalizedPoints = len(PointSet) * [0]
      
      # Normalize S-I dimension to R-L scale
      for i, Point in enumerate(PointSet):
        Coords = Point[1]
        NormalizedPoints[i] = np.array([Coords[0], (Coords[1]) * (SetWidth / (SetDepth * 3.0)), (Coords[2]) * (SetWidth / (SetHeight * 2.0))])
      return NormalizedPoints
    
    def ShouldStopKMeans(self, oldCentroids, Centroids, iterations):
      MaxIterations = 500
      StoppingDelta = 0.05
      #print oldCentroids, Centroids
      if iterations > MaxIterations: return True
      if iterations == 0:
        return False
      for C in range(len(oldCentroids)):
        #print oldCentroids[C], Centroids[C]
        if np.linalg.norm(oldCentroids[C] - Centroids[C]) < StoppingDelta:
          return True
      return False

    def GetKMeansLabels(self, DataSet, Centroids, Labels):
      for i, Coords in enumerate(DataSet):
        #PointCentroidDistance = np.linalg.norm(Coords - Centroids[0])
        minDist = 1000000
        Labels[i] = 0
        for j, CentroidVector in enumerate(Centroids):
          #print Coords, CentroidVector#, np.linalg.norm(Coords - CentroidVector)
          PointCentroidDistance = np.linalg.norm(Coords - CentroidVector)
          if PointCentroidDistance < minDist:
            minDist = PointCentroidDistance
            Labels[i] = j
      return Labels

    def GetCentroids(self, DataSet, Labels, k):
      Centroids = []
      #print Labels
      for C in range(k):    # For each centroid
        Centroid = np.random.uniform() * np.ones(len(DataSet[0]))    # Each centroid with as many dimensions as the data
        
        for i, Coords in enumerate(DataSet): # Take each data point contributing to the centroid into consideration
          if Labels[i] == C:                    # if it belongs to the current centroid
            for dim in range(len(Centroid)):
              Centroid[dim] += Coords[dim]
              
        for dim in range(len(Centroid)):
          Centroid[dim] = Centroid[dim] / np.count_nonzero(Labels == C)
        Centroids.append(Centroid)
      return Centroids

    def KMeans(self, DataSet, k=2):   # Expects DataSet as list of (Label, np.array[R,A,S]) tuples, uses k=2 by default for left and right sides
      DataSetLabels = np.zeros(len(DataSet))
      for i in range(len(DataSetLabels)):
        DataSetLabels[i] = int(round(np.random.uniform()))
      # Initialize centroids
      numFeatures = len(DataSet[0])
      Centroids = k * [0]
      # Try initializing one centroid on each side
      Centroids[0] = np.array([min([i[0] for i in DataSet]),0,0])
      Centroids[1] = np.array([max([i[0] for i in DataSet]),0,0])
      
    # Initialize book keeping variables
      iterations = 0
      oldCentroids = k * [0]
      for Cent in range(k):
        oldCentroids[Cent] = np.array(numFeatures * [np.random.uniform()])

      # Run the k-means algorithm
      while not self.ShouldStopKMeans(oldCentroids, Centroids, iterations):
        oldCentroids = Centroids
        iterations += 1
        
        DataSetLabels = self.GetKMeansLabels(DataSet, Centroids, DataSetLabels)
        Centroids = self.GetCentroids(DataSet, DataSetLabels, k)
        #print Centroids
      return (DataSetLabels, Centroids)

    def CombineRepairedSides(self):
      PriorNode = slicer.util.getNode(self.MarkupsNode.GetName() + "_Repaired")
      if PriorNode != None:
        slicer.mrmlScene.RemoveNode(PriorNode)
      
      LeftLabelCoords = [(self.LeftSide.MarkupsNode.GetNthFiducialLabel(i), self.LeftSide.MarkupsNode.GetMarkupPointVector(i,0)) for i in range(self.LeftSide.MarkupsNode.GetNumberOfFiducials())]
      SortedLeftLabelCoords = sorted(LeftLabelCoords, key=lambda Tup: -1*Tup[1][2])
      RightLabelsCoords = [(self.RightSide.MarkupsNode.GetNthFiducialLabel(j), self.RightSide.MarkupsNode.GetMarkupPointVector(j,0)) for j in range(self.RightSide.MarkupsNode.GetNumberOfFiducials())]
      SortedRightLabelCoords = sorted(RightLabelsCoords, key=lambda Tup: -1*Tup[1][2])
      
      CombinedLabelCoords = []
      for i, (LeftPoint, RightPoint) in enumerate(zip(LeftLabelCoords, RightLabelsCoords)):
        CombinedLabelCoords.append(LeftPoint)
        CombinedLabelCoords.append(RightPoint)
      #CombinedLabelCoords = LeftLabelCoords + RightLabelsCoords
      
      RepairedNode = slicer.vtkMRMLMarkupsFiducialNode()
      RepairedNode.SetName(self.MarkupsNode.GetName() + "_Repaired")
      
      for i, LabelCoord in enumerate(CombinedLabelCoords):
        RepairedNode.AddFiducialFromArray(LabelCoord[1])
        RepairedNode.SetNthFiducialLabel(i, LabelCoord[0] + "_Rep")
      #slicer.mrmlScene.AddNode(RepairedNode)
      
  class SpineSide:
    def __init__(self, parent, Node):
      self.ParentPatient = parent
      self.PointsPerPolynomialCurve = 500
      
      self.MarkupsNode = slicer.vtkMRMLMarkupsFiducialNode()
      self.MarkupsNode.Copy(Node)
      
      self.PatchNode = slicer.vtkMRMLMarkupsFiducialNode()
      self.PatchNode.SetName(parent.MarkupsNode.GetName() + "_Patch")
      
      # Each element corresponds to an interval of self.MarkupsNode identified as having omissions,
      self.SubPatchesPointCounts = []      # the value represents the number of omissions to be estimated in self.PatchNode
      
      #self.ImputationErrorImprovementThreshold = 0.05
     
    def OrderPointsSuperiorToInferior(self, Node):
      #print  "Sorting node " + Node.GetName() + " landmarks"
      LabelsCoords = [(Node.GetNthFiducialLabel(i), Node.GetMarkupPointVector(i,0)) for i in range(Node.GetNumberOfFiducials())]
      Node.RemoveAllMarkups()
      LabelsCoords = sorted(LabelsCoords, key=lambda Tup: -1*Tup[1][2])
      for i, (Label, Coord) in enumerate(LabelsCoords):
        Node.AddFiducialFromArray(Coord)
        Node.SetNthFiducialLabel(i, Label)
     
    def CombineNodeWithPatch(self, BaseNode, PatchNode):
      # Returns a node containing the original markups points, and those from the patch - used to check patch fit improvements
      TentativeNode = slicer.vtkMRMLMarkupsFiducialNode()
      OriginalLabelPoints = [(BaseNode.GetNthFiducialLabel(i), BaseNode.GetMarkupPointVector(i,0)) for i in range(BaseNode.GetNumberOfFiducials())]
      PatchLabelPoints = [(PatchNode.GetNthFiducialLabel(i), PatchNode.GetMarkupPointVector(i,0)) for i in range(PatchNode.GetNumberOfFiducials())]
      AllLabelPoints = OriginalLabelPoints + PatchLabelPoints
      
      # Also sort points
      AllLabelPoints = sorted(AllLabelPoints, key=lambda LabelPoint: -1*LabelPoint[1][2])
      
      for i, (Label, Coords) in enumerate(AllLabelPoints):
        TentativeNode.AddFiducialFromArray(Coords)
        TentativeNode.SetNthFiducialLabel(i, Label)
        
      return TentativeNode
     
    def CoordsPolyFit(self, Node):
      #Coords = [self.MarkupsNode.GetMarkupPointVector(i,0) for i in range(self.MarkupsNode.GetNumberOfFiducials())]
      #print Coords
      #LabelsCoords = [(self.MarkupsNode.GetNthFiducialLabel(i), self.MarkupsNode.GetMarkupPointVector(i,0)) for i in range(self.MarkupsNode.GetNumberOfFiducials())]
      LabelsCoords = [(Node.GetNthFiducialLabel(i), Node.GetMarkupPointVector(i,0)) for i in range(Node.GetNumberOfFiducials())]
      R = [LabelsCoords[i][1][0] for i in range(len(LabelsCoords))]
      A = [LabelsCoords[i][1][1] for i in range(len(LabelsCoords))]
      S = [LabelsCoords[i][1][2] for i in range(len(LabelsCoords))]
      sSpace = np.linspace(S[0], S[-1], self.PointsPerPolynomialCurve)

      # The degrees of these polynomials should not be hard coded
      S_R_FitCoefs = np.polyfit(S, R, 5)
      S_A_FitCoefs = np.polyfit(S, A, 4)
      
      SrPolynomial = np.poly1d(S_R_FitCoefs)
      SaPolynomial = np.poly1d(S_A_FitCoefs)
  
      return (SrPolynomial, SaPolynomial)
      
    def GetCurvewiseInterpointDistances(self, Node, SrPolynomial, SaPolynomial):
      #Coords = [self.MarkupsNode.GetMarkupPointVector(i,0) for i in range(self.MarkupsNode.GetNumberOfFiducials())]
      LabelsCoords = [(Node.GetNthFiducialLabel(i), Node.GetMarkupPointVector(i,0)) for i in range(Node.GetNumberOfFiducials())]
      R = [LabelsCoords[i][1][0] for i in range(len(LabelsCoords))]
      A = [LabelsCoords[i][1][1] for i in range(len(LabelsCoords))]
      S = [LabelsCoords[i][1][2] for i in range(len(LabelsCoords))]
      sSpace = np.linspace(S[0], S[-1], self.PointsPerPolynomialCurve)
     
      # Distances along the polynomial to each landmark in the given dimension
      PointDistances = []
      #priorS = sSpace[0]
      sIndex = 1
      
      # Find points in sSpace corresponding to landmarks in both R and A dimension
      CurveDistance = 0
      for i, Landmark in enumerate(zip(R[:-1],A[:-1])):
        CurrentIntervalLength = 0
        while sIndex < self.PointsPerPolynomialCurve and sSpace[sIndex] > S[i+1]:
          PriorS = sSpace[sIndex-1]
          CurrentS = sSpace[sIndex]
          PriorR = SrPolynomial(PriorS)
          CurrentR = SrPolynomial(CurrentS)
          PriorA = SaPolynomial(PriorS)
          CurrentA = SaPolynomial(CurrentS)
          CurveIncrementDistance = np.sqrt(((CurrentS - PriorS)**2) + ((CurrentR - PriorR)**2) + ((CurrentA - PriorA)**2)) 
          CurrentIntervalLength += CurveIncrementDistance
          CurveDistance += CurveIncrementDistance
          sIndex += 1
        PointDistances.append((CurveDistance, CurrentIntervalLength))
          
      return PointDistances
      
    def FrequencyPolyFit(self, IntervalData):
      IntervalDistances = [IntervalData[i][1] for i in range(len(IntervalData))]
      
      # Try fitting polynomial to relationship between total distance travelled down the spine to the inter-landmark distances
      CumulativeDistance = 0
      CumulativeCurveDistances = []
      for i, Interval in enumerate(IntervalDistances):
        CumulativeCurveDistances.append(CumulativeDistance + (Interval/2.0))
        CumulativeDistance += Interval
      
      CurveSpace = np.linspace(0, CumulativeDistance, self.PointsPerPolynomialCurve)
      FrequencyCoeffs = np.polyfit(CumulativeCurveDistances, IntervalDistances, 2)
      FrequencyPolynomial = np.poly1d(FrequencyCoeffs)
      
      return FrequencyPolynomial
      
    def GetPolyfitErrors(self, Data, Polynomial):
      FitErrors = []
      for Datum in Data:
        PolyPrediction = Polynomial(Datum[0])
        PredictionError = Datum[1] - PolyPrediction
        FitErrors.append(PredictionError)
      return FitErrors
  
    def GetPolyfitRMS(self, FitErrors):
      if len(FitErrors) == 0:
        print "Computing RMS error of empty error set - returning 0"
        return 0
      else:
        SumSquaredError = sum([(Error)**2 for Error in FitErrors])
        RMS = np.sqrt(SumSquaredError)
        #print RMS
        return RMS
       
    def IdentifyOmissionsFromLocalDistances(self, IntervalIndex, IntervalData):
      IntervalLength = IntervalData[IntervalIndex][1]
      
      # The first interval is a boundary, having only one neighboring interval
      if IntervalIndex == 0:
        NextIntervalLength = IntervalData[IntervalIndex+1][1]
        if NextIntervalLength < 0.75*IntervalLength:
          return True
        else:
          return False
          
      # The last interval is also a boundary condiditon
      if IntervalIndex == len(IntervalData)-1:
        PriorIntervalLength = IntervalData[IntervalIndex-1][1]
        if PriorIntervalLength < 0.75*IntervalLength:
          return True
        else:
          return False
          
      #else:
      NextIntervalLength = IntervalData[IntervalIndex+1][1]
      PriorIntervalLength = IntervalData[IntervalIndex-1][1]
      if NextIntervalLength < 0.75*IntervalLength or PriorIntervalLength < 0.75*IntervalLength:
        return True
      else:
        return False
   
    def IdentifyOmissionsFromIntervalLengthFit(self, IntervalIndex, FitErrors):
      AbsErrors = [abs(E) for E in FitErrors]
      IntervalError = FitErrors[IntervalIndex]
      MeanAbsError = np.mean(AbsErrors)
      ErrorStdDev = np.std(FitErrors)
      
      # The first interval is a boundary, having only one neighboring interval
      if IntervalIndex == 0:
        if abs(IntervalError) > MeanAbsError + 2*ErrorStdDev:
          return True
        else:
          return False
          
      # The last interval is also a boundary condiditon
      elif IntervalIndex == len(FitErrors)-1:
        if abs(IntervalError) > MeanAbsError + 2*ErrorStdDev:
          return True
        else:
          return False
          
      else:
        PriorIntervalError = FitErrors[IntervalIndex-1]
        NextIntervalError = FitErrors[IntervalIndex+1]
        if (np.sign(IntervalError) != np.sign(PriorIntervalError) and abs(PriorIntervalError)!=max(AbsErrors)) and (np.sign(IntervalError) != np.sign(NextIntervalError) and abs(NextIntervalError)!=max(AbsErrors)) and (abs(IntervalError) > MeanAbsError):
          return True
        if abs(IntervalError) > MeanAbsError + 2*ErrorStdDev:
          return True
        else:
          return False
    
    def IdentifyOmissionsFromLocalIntervalLengths(self, IntervalIndex, IntervalData):
      IntervalLengths = [IntervalData[i][1] for i in range(len(IntervalData))]
      IntervalLengthMean = np.mean(IntervalLengths)
      IntervalLengthStd = np.std(IntervalLengths)
      
      CurrentIntervalLength = IntervalLengths[IntervalIndex]
      
      # Boundary condition checks leave the possibility that two intervals with omissions neighbor
      
      # Superior-most boundary condition - only one neighbor, below
      if IntervalIndex == 0:
        NextIntervalLength = IntervalLengths[IntervalIndex+1]
        if CurrentIntervalLength > NextIntervalLength + (1*IntervalLengthStd):
          return True
        else:
          return False
        
      # Inferior-most boundary condition - only one neighbor, above
      if IntervalIndex == len(IntervalData)-1:
        PriorIntervalLength = IntervalLengths[IntervalIndex-1]
        if CurrentIntervalLength > PriorIntervalLength + (1*IntervalLengthStd):
          return True
        else:
          return False
      
      else:         # Interval is somewhere in the middle, with two neighbors
        NextIntervalLength = IntervalLengths[IntervalIndex+1]
        PriorIntervalLength = IntervalLengths[IntervalIndex-1]
        if CurrentIntervalLength > NextIntervalLength + (1*IntervalLengthStd) or CurrentIntervalLength > PriorIntervalLength + (1*IntervalLengthStd):
          return True
        else:
          return False
     
    def EstimateOmissions(self, Node, IntervalIndex, IntervalData):   # Finds and adds the optimum number of points to a given interval to minimize the entire curve's frequency fit RMS
      # Returns CountEstimate - If CountEstimate == 0 and this method was called, an infinite loop may result from omissions being identified and never fixed
      LabelsCoords = [(Node.GetNthFiducialLabel(i), Node.GetMarkupPointVector(i,0)) for i in range(Node.GetNumberOfFiducials())]
      S = [LabelsCoords[i][1][2] for i in range(len(LabelsCoords))]
      
      # Initialize original measures for comparison
      (OriginalSr, OriginalSa) = self.CoordsPolyFit(Node)
      OriginalFreqPoly = self.FrequencyPolyFit(IntervalData)
      OriginalFitErrors = self.GetPolyfitErrors(IntervalData, OriginalFreqPoly)
      BestRMS = self.GetPolyfitRMS(OriginalFitErrors)
      BestIntervalFitError = abs(OriginalFitErrors[IntervalIndex])
      #print OriginalFitErrors
      
      # Try one imputation, as boundary, to get initial tentative improvement
      CountEstimate = 1
      

      SubPatchNode = slicer.vtkMRMLMarkupsFiducialNode()
      #TentativeRepaireNode = slicer.vtkMRMLMarkupsFiducialNode()
      NewSLocations = np.linspace(S[IntervalIndex], S[IntervalIndex+1], CountEstimate+2)[1:-1]
      for x in NewSLocations: 
        SubPatchNode.AddFiducialFromArray([OriginalSr(x), OriginalSa(x), x])
        #TentativePatchNode.AddFiducialFromArray([OriginalSr(x), OriginalSa(x), x])
              
      # Create Node containing MarkupsNode combined with tentative subpatches to see how the number of imputations improves fit
      TentativeRepairNode = slicer.vtkMRMLMarkupsFiducialNode()
      TentativeRepairNode.Copy(self.CombineNodeWithPatch(Node, SubPatchNode))
      TentativeRepairNode.SetName("TentPat")
      #slicer.mrmlScene.AddNode(TentativeRepairNode)
      
      # Create TentativeSide object for operations needed to reasses fit error
      TentativeSide = self.ParentPatient.ParentLogic.SpineSide(self.ParentPatient, TentativeRepairNode)
      TentativeSide.OrderPointsSuperiorToInferior(TentativeSide.MarkupsNode)
      
      # Use said operations to update measures
      (TentSrPoly, TentSaPoly) = TentativeSide.CoordsPolyFit(TentativeSide.MarkupsNode)
      #TentInterpointData = TentativeSide.GetCurvewiseInterpointDistances(OriginalSr, OriginalSa)
      TentInterpointData = TentativeSide.GetCurvewiseInterpointDistances(TentativeSide.MarkupsNode, TentSrPoly, TentSaPoly)
      TentFreqPolynomial = TentativeSide.FrequencyPolyFit(TentInterpointData)
      TentFitErrors = TentativeSide.GetPolyfitErrors(TentInterpointData, TentFreqPolynomial)
      #TentFitErrors = TentativeSide.GetPolyfitErrors(TentInterpointData, OriginalFreqPoly)
      TentRMS = TentativeSide.GetPolyfitRMS(TentFitErrors)
      # TentIntervalFitError is weighted (multiplied) by the number of points being added to penalize adding many points
      TentIntervalFitError = np.mean([abs(Error) for Error in TentFitErrors[IntervalIndex:IntervalIndex+CountEstimate+1]])
      
      # Try 2 or more imputations in the interval, see if the freq. fit improves
      print " About to test imputation"
      
      while TentIntervalFitError - BestIntervalFitError < 0:    # While the latest addition improved the frequency fit over the original polynomial
        print ""
       #print TentIntervalFitError - BestIntervalFitError
        #print TentFitErrors
        print CountEstimate
        print ""
        CountEstimate += 1            # Try adding one more point
        BestRMS = TentRMS
        BestIntervalFitError = TentIntervalFitError

        #TentativePatchNode.Copy(self.MarkupsNode)
        # Create SubPatchNode and add points by interpolating Node characteristic polynomials
        SubPatchNode = slicer.vtkMRMLMarkupsFiducialNode()
        NewSLocations = np.linspace(S[IntervalIndex], S[IntervalIndex+1], CountEstimate+2)[1:-1]
        for x in NewSLocations: 
          SubPatchNode.AddFiducialFromArray([OriginalSr(x), OriginalSa(x), x])
          #TentativePatchNode.AddFiducialFromArray([OriginalSr(x), OriginalSa(x), x])
      
        TentativeRepairNode.Copy(self.CombineNodeWithPatch(TentativeRepairNode, SubPatchNode))
        TentativeRepairNode.SetName("TentRepair")
        TentativeSide = self.ParentPatient.ParentLogic.SpineSide(self.ParentPatient, TentativeRepairNode)
        TentativeSide.OrderPointsSuperiorToInferior(TentativeSide.MarkupsNode)
        (TentSrPoly, TentSaPoly) = TentativeSide.CoordsPolyFit(TentativeSide.MarkupsNode)
        TentInterpointData = TentativeSide.GetCurvewiseInterpointDistances(TentativeSide.MarkupsNode, TentSrPoly, TentSaPoly)
        #TentInterpointData = TentativeSide.GetCurvewiseInterpointDistances(OriginalSr, OriginalSa)
        TentFreqPolynomial = TentativeSide.FrequencyPolyFit(TentInterpointData)
        TentFitErrors = TentativeSide.GetPolyfitErrors(TentInterpointData, TentFreqPolynomial)
        #TentFitErrors = TentativeSide.GetPolyfitErrors(TentInterpointData, OriginalFreqPoly)
        TentRMS = TentativeSide.GetPolyfitRMS(TentFitErrors)
        TentIntervalFitError = np.mean([abs(Error) for Error in TentFitErrors[IntervalIndex:IntervalIndex+CountEstimate+1]])
        
      print " Done testing imputation"
        
      # ASSERT TentRMS > BestRMS, because CountEstimate is one too high
      CountEstimate -= 1
      #print CountEstimate
      
      # Create node with optimum number of imputations

      SubPatchNode = slicer.vtkMRMLMarkupsFiducialNode()
      SubPatchNode.SetName(self.MarkupsNode.GetName() + "_SubPatch-" + str(IntervalIndex))

      NewSLocations = np.linspace(S[IntervalIndex], S[IntervalIndex+1], CountEstimate+2)[1:-1]
      for i, x in enumerate(NewSLocations): 
        SubPatchNode.AddFiducialFromArray([OriginalSr(x), OriginalSa(x), x])
        NewLabel = str("SubPatch-" + str(len(self.SubPatchesPointCounts)) + "_Point-" + str(i))
        print ""
        SubPatchNode.SetNthFiducialLabel(i, NewLabel)

      #self.OrderPointsSuperiorToInferior(SubPatchNode)

      return SubPatchNode
      
    def PredictAndImputeOmissions(self):
      self.SubPatchesPointCounts = []  # Reinitialize
      SkipIntervals = np.zeros(self.MarkupsNode.GetNumberOfFiducials()-1)   # Used to keep track of which intervals were tested for omissions - IdentifyOmissionsFromIntervalLengthFit may indicate omissions while EstimateOmissions might impute none
      
      PriorPatchNode = slicer.util.getNode(self.MarkupsNode.GetName() + "_Patch")
      if PriorPatchNode != None:
        slicer.mrmlScene.RemoveNode(PriorPatchNode)
      
      #OriginalMarkupsNode = slicer.vtkMRMLMarkupsFiducialNode()
      #OriginalMarkupsNode.Copy(self.MarkupsNode)
      
      SubPatchNode = slicer.vtkMRMLMarkupsFiducialNode()
      PatchNode = slicer.vtkMRMLMarkupsFiducialNode()
      
      TentativeRepairNode = slicer.vtkMRMLMarkupsFiducialNode()
      TentativeRepairNode.Copy(self.MarkupsNode)
        
      (SrPolynomial, SaPolynomial) = self.CoordsPolyFit(self.MarkupsNode)
      CurvewiseInterpointData = self.GetCurvewiseInterpointDistances(self.MarkupsNode, SrPolynomial, SaPolynomial)
      CurvewiseFrequencyPolynomial = self.FrequencyPolyFit(CurvewiseInterpointData)
      FrequencyFitErrors = self.GetPolyfitErrors(CurvewiseInterpointData, CurvewiseFrequencyPolynomial)

      print "About to look for intervals with omissions"
      ImputingPoints = True
      while ImputingPoints:
        ImputingPoints = False
        
        for TentativeInterval, (IntervalDatum, FitError) in enumerate(zip(CurvewiseInterpointData, FrequencyFitErrors), start=sum(self.SubPatchesPointCounts)):
          # For each interval in the TentativeRepairNode
          CorrespondingOriginalInterval = TentativeInterval - sum(self.SubPatchesPointCounts)
          if not SkipIntervals[TentativeInterval] and (self.IdentifyOmissionsFromIntervalLengthFit(CorrespondingOriginalInterval, FrequencyFitErrors) or self.IdentifyOmissionsFromLocalIntervalLengths(CorrespondingOriginalInterval, CurvewiseInterpointData)):
            print "Interval " + str(CorrespondingOriginalInterval) + " apparently missing points"
            ImputingPoints = True
            print CorrespondingOriginalInterval, TentativeInterval
            
            # Find optimum number of points to impute in interval i
            SubPatchNode = self.EstimateOmissions(TentativeRepairNode, CorrespondingOriginalInterval, CurvewiseInterpointData)
            
            # Keep track of interval changes
            NumImputations = SubPatchNode.GetNumberOfFiducials()
            self.SubPatchesPointCounts.append(NumImputations)
            SkipIntervals = np.insert(SkipIntervals, TentativeInterval, np.ones(NumImputations+1))      # Don't check intervals we've already identified as incomplete - infinite loop
            
            # Update node tracking overall patch improvement
            TentativeRepairNode = self.CombineNodeWithPatch(TentativeRepairNode, SubPatchNode)
            
            # Update node characteristics
            (SrPolynomial, SaPolynomial) = self.CoordsPolyFit(TentativeRepairNode)
            CurvewiseInterpointData = self.GetCurvewiseInterpointDistances(TentativeRepairNode, SrPolynomial, SaPolynomial)
            CurvewiseFrequencyPolynomial = self.FrequencyPolyFit(CurvewiseInterpointData)
            FrequencyFitErrors = self.GetPolyfitErrors(CurvewiseInterpointData, CurvewiseFrequencyPolynomial)
            break               # Start again from the top of the newly shaped (frequency fit) spine
        
        #self.MarkupsNode = self.CombineNodeWithPatch(self.MarkupsNode, SubPatchNode)
        #self.MarkupsNode.SetName(OriginalMarkupsNode.GetName())
        PatchNode = self.CombineNodeWithPatch(PatchNode, SubPatchNode)
        #PatchNode.Copy(TentativeRepairNode)
        #TentativeRepairNode = self.CombineNodeWithPatch(TentativeRepairNode, SubPatchNode)
        SubPatchNode.RemoveAllMarkups()
      print "Done looking for intervals with omissions"
      
      #self.PatchNode = slicer.vtkMRMLMarkupsFiducialNode()
      #self.PatchNode.Copy(self.MarkupsNode)
      self.PatchNode.Copy(PatchNode)
      self.PatchNode.SetName(self.MarkupsNode.GetName() + "_Patch")
      #self.MarkupsNode.Copy(OriginalMarkupsNode)                              # Restore MarkupsNode to its unrepaired state
      
      return self.PatchNode
    
  def __init__(self, Markups):
    #  Instantiation of PatientModel here performs initial left-right classification into self.PatientModel.LeftSide etc...
    self.PatientModel = self.PatientTransverseProcesses(self, Markups)
        
  def CategorizeLeftRight(self, WindowSize):
    self.PatientModel.ClassifyLeftRight(WindowSize)
    self.LeftSide = self.PatientModel.LeftSide    
    self.RightSide = self.PatientModel.RightSide
    
    LMNc = slicer.vtkMRMLMarkupsFiducialNode()
    LMNc.Copy(self.LeftSide.MarkupsNode)
    RMNc = slicer.vtkMRMLMarkupsFiducialNode()
    RMNc.Copy(self.RightSide.MarkupsNode)
    
    return (LMNc, RMNc)
    #return (self.LeftSide.MarkupsNode, self.RightSide.MarkupsNode)
    #return (slicer.mrmlScene.CopyNode(self.LeftSide.MarkupsNode), slicer.mrmlScene.CopyNode(self.RightSide.MarkupsNode))
    
  def RepairNode(self):
    
    self.LeftSide.OrderPointsSuperiorToInferior(self.LeftSide.MarkupsNode)
    self.LeftSide.PredictAndImputeOmissions()
    
    self.RightSide.OrderPointsSuperiorToInferior(self.RightSide.MarkupsNode)
    self.RightSide.PredictAndImputeOmissions()
    
    self.PatientModel.CombineRepairedSides()

class PreProcessLandmarksTest(ScriptedLoadableModuleTest):
  """
  This is the test case for your scripted module.
  Uses ScriptedLoadableModuleTest base class, available at:
  https://github.com/Slicer/Slicer/blob/master/Base/Python/slicer/ScriptedLoadableModule.py
  """

  def setUp(self):
    """ Do whatever is needed to reset the state - typically a scene clear will be enough.
    """
    slicer.mrmlScene.Clear(0)

  def runTest(self):
    """Run as few or as many tests as needed here.
    """
    self.setUp()
    self.test_PreProcessLandmarks1()

  def test_PreProcessLandmarks1(self):
    """ Ideally you should have several levels of tests.  At the lowest level
    tests should exercise the functionality of the logic with different inputs
    (both valid and invalid).  At higher levels your tests should emulate the
    way the user would interact with your code and confirm that it still works
    the way you intended.
    One of the most important features of the tests is that it should alert other
    developers when their changes will have an impact on the behavior of your
    module.  For example, if a developer removes a feature that you depend on,
    your test should break so they know that the feature is needed.
    """

    self.delayDisplay("Starting the test")
    #
    # first, get some data
    #
    import urllib
    downloads = (
        ('http://slicer.kitware.com/midas3/download?items=5767', 'FA.nrrd', slicer.util.loadVolume),
        )

    for url,name,loader in downloads:
      filePath = slicer.app.temporaryPath + '/' + name
      if not os.path.exists(filePath) or os.stat(filePath).st_size == 0:
        logging.info('Requesting download %s from %s...\n' % (name, url))
        urllib.urlretrieve(url, filePath)
      if loader:
        logging.info('Loading %s...' % (name,))
        loader(filePath)
    self.delayDisplay('Finished with download and loading')

    volumeNode = slicer.util.getNode(pattern="FA")
    logic = PreProcessLandmarksLogic()
    self.assertIsNotNone( logic.hasImageData(volumeNode) )
    self.delayDisplay('Test passed!')
